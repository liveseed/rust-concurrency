//! keysinterface provides keys into rust-lightning and defines some useful enums which describe
//! spendable on-chain outputs which the user owns and is responsible for using just as any other
//! on-chain output which is theirs.

use std::ffi::c_void;
use bitcoin::hashes::Hash;
use crate::c_types::*;

/// When on-chain outputs are created by rust-lightning (which our counterparty is not able to
/// claim at any point in the future) an event is generated which you must track and be able to
/// spend on-chain. The information needed to do this is provided in this enum, including the
/// outpoint describing which txid and output index is available, the full output which exists at
/// that txid/index, and any keys or other information required to sign.
#[must_use]
#[derive(Clone)]
#[repr(C)]
pub enum SpendableOutputDescriptor {
	/// An output to a script which was provided via KeysInterface, thus you should already know
	/// how to spend it. No keys are provided as rust-lightning was never given any keys - only the
	/// script_pubkey as it appears in the output.
	/// These may include outputs from a transaction punishing our counterparty or claiming an HTLC
	/// on-chain using the payment preimage or after it has timed out.
	StaticOutput {
		outpoint: crate::chain::transaction::OutPoint,
		output: crate::c_types::TxOut,
	},
	/// An output to a P2WSH script which can be spent with a single signature after a CSV delay.
	///
	/// The witness in the spending input should be:
	/// <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
	///
	/// Note that the nSequence field in the spending input must be set to to_self_delay
	/// (which means the transaction is not broadcastable until at least to_self_delay
	/// blocks after the outpoint confirms).
	///
	/// These are generally the result of a \"revocable\" output to us, spendable only by us unless
	/// it is an output from an old state which we broadcast (which should never happen).
	///
	/// To derive the delayed_payment key which is used to sign for this input, you must pass the
	/// holder delayed_payment_base_key (ie the private key which corresponds to the pubkey in
	/// ChannelKeys::pubkeys().delayed_payment_basepoint) and the provided per_commitment_point to
	/// chan_utils::derive_private_key. The public key can be generated without the secret key
	/// using chan_utils::derive_public_key and only the delayed_payment_basepoint which appears in
	/// ChannelKeys::pubkeys().
	///
	/// To derive the revocation_pubkey provided here (which is used in the witness
	/// script generation), you must pass the counterparty revocation_basepoint (which appears in the
	/// call to ChannelKeys::on_accept) and the provided per_commitment point
	/// to chan_utils::derive_public_revocation_key.
	///
	/// The witness script which is hashed and included in the output script_pubkey may be
	/// regenerated by passing the revocation_pubkey (derived as above), our delayed_payment pubkey
	/// (derived as above), and the to_self_delay contained here to
	/// chan_utils::get_revokeable_redeemscript.
	DynamicOutputP2WSH {
		outpoint: crate::chain::transaction::OutPoint,
		per_commitment_point: crate::c_types::PublicKey,
		to_self_delay: u16,
		output: crate::c_types::TxOut,
		key_derivation_params: crate::c_types::derived::C2Tuple_u64u64Z,
		revocation_pubkey: crate::c_types::PublicKey,
	},
	/// An output to a P2WPKH, spendable exclusively by our payment key (ie the private key which
	/// corresponds to the public key in ChannelKeys::pubkeys().payment_point).
	/// The witness in the spending input, is, thus, simply:
	/// <BIP 143 signature> <payment key>
	///
	/// These are generally the result of our counterparty having broadcast the current state,
	/// allowing us to claim the non-HTLC-encumbered outputs immediately.
	StaticOutputCounterpartyPayment {
		outpoint: crate::chain::transaction::OutPoint,
		output: crate::c_types::TxOut,
		key_derivation_params: crate::c_types::derived::C2Tuple_u64u64Z,
	},
}
use lightning::chain::keysinterface::SpendableOutputDescriptor as nativeSpendableOutputDescriptor;
impl SpendableOutputDescriptor {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeSpendableOutputDescriptor {
		match self {
			SpendableOutputDescriptor::StaticOutput {ref outpoint, ref output, } => {
				let mut outpoint_nonref = (*outpoint).clone();
				let mut output_nonref = (*output).clone();
				nativeSpendableOutputDescriptor::StaticOutput {
					outpoint: *unsafe { Box::from_raw(outpoint_nonref.take_ptr()) },
					output: output_nonref.into_rust(),
				}
			},
			SpendableOutputDescriptor::DynamicOutputP2WSH {ref outpoint, ref per_commitment_point, ref to_self_delay, ref output, ref key_derivation_params, ref revocation_pubkey, } => {
				let mut outpoint_nonref = (*outpoint).clone();
				let mut per_commitment_point_nonref = (*per_commitment_point).clone();
				let mut to_self_delay_nonref = (*to_self_delay).clone();
				let mut output_nonref = (*output).clone();
				let mut key_derivation_params_nonref = (*key_derivation_params).clone();
				let (mut orig_key_derivation_params_nonref_0, mut orig_key_derivation_params_nonref_1) = key_derivation_params_nonref.to_rust(); let mut local_key_derivation_params_nonref = (orig_key_derivation_params_nonref_0, orig_key_derivation_params_nonref_1);
				let mut revocation_pubkey_nonref = (*revocation_pubkey).clone();
				nativeSpendableOutputDescriptor::DynamicOutputP2WSH {
					outpoint: *unsafe { Box::from_raw(outpoint_nonref.take_ptr()) },
					per_commitment_point: per_commitment_point_nonref.into_rust(),
					to_self_delay: to_self_delay_nonref,
					output: output_nonref.into_rust(),
					key_derivation_params: local_key_derivation_params_nonref,
					revocation_pubkey: revocation_pubkey_nonref.into_rust(),
				}
			},
			SpendableOutputDescriptor::StaticOutputCounterpartyPayment {ref outpoint, ref output, ref key_derivation_params, } => {
				let mut outpoint_nonref = (*outpoint).clone();
				let mut output_nonref = (*output).clone();
				let mut key_derivation_params_nonref = (*key_derivation_params).clone();
				let (mut orig_key_derivation_params_nonref_0, mut orig_key_derivation_params_nonref_1) = key_derivation_params_nonref.to_rust(); let mut local_key_derivation_params_nonref = (orig_key_derivation_params_nonref_0, orig_key_derivation_params_nonref_1);
				nativeSpendableOutputDescriptor::StaticOutputCounterpartyPayment {
					outpoint: *unsafe { Box::from_raw(outpoint_nonref.take_ptr()) },
					output: output_nonref.into_rust(),
					key_derivation_params: local_key_derivation_params_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeSpendableOutputDescriptor {
		match self {
			SpendableOutputDescriptor::StaticOutput {mut outpoint, mut output, } => {
				nativeSpendableOutputDescriptor::StaticOutput {
					outpoint: *unsafe { Box::from_raw(outpoint.take_ptr()) },
					output: output.into_rust(),
				}
			},
			SpendableOutputDescriptor::DynamicOutputP2WSH {mut outpoint, mut per_commitment_point, mut to_self_delay, mut output, mut key_derivation_params, mut revocation_pubkey, } => {
				let (mut orig_key_derivation_params_0, mut orig_key_derivation_params_1) = key_derivation_params.to_rust(); let mut local_key_derivation_params = (orig_key_derivation_params_0, orig_key_derivation_params_1);
				nativeSpendableOutputDescriptor::DynamicOutputP2WSH {
					outpoint: *unsafe { Box::from_raw(outpoint.take_ptr()) },
					per_commitment_point: per_commitment_point.into_rust(),
					to_self_delay: to_self_delay,
					output: output.into_rust(),
					key_derivation_params: local_key_derivation_params,
					revocation_pubkey: revocation_pubkey.into_rust(),
				}
			},
			SpendableOutputDescriptor::StaticOutputCounterpartyPayment {mut outpoint, mut output, mut key_derivation_params, } => {
				let (mut orig_key_derivation_params_0, mut orig_key_derivation_params_1) = key_derivation_params.to_rust(); let mut local_key_derivation_params = (orig_key_derivation_params_0, orig_key_derivation_params_1);
				nativeSpendableOutputDescriptor::StaticOutputCounterpartyPayment {
					outpoint: *unsafe { Box::from_raw(outpoint.take_ptr()) },
					output: output.into_rust(),
					key_derivation_params: local_key_derivation_params,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &nativeSpendableOutputDescriptor) -> Self {
		match native {
			nativeSpendableOutputDescriptor::StaticOutput {ref outpoint, ref output, } => {
				let mut outpoint_nonref = (*outpoint).clone();
				let mut output_nonref = (*output).clone();
				SpendableOutputDescriptor::StaticOutput {
					outpoint: crate::chain::transaction::OutPoint { inner: Box::into_raw(Box::new(outpoint_nonref)), is_owned: true },
					output: crate::c_types::TxOut::from_rust(output_nonref),
				}
			},
			nativeSpendableOutputDescriptor::DynamicOutputP2WSH {ref outpoint, ref per_commitment_point, ref to_self_delay, ref output, ref key_derivation_params, ref revocation_pubkey, } => {
				let mut outpoint_nonref = (*outpoint).clone();
				let mut per_commitment_point_nonref = (*per_commitment_point).clone();
				let mut to_self_delay_nonref = (*to_self_delay).clone();
				let mut output_nonref = (*output).clone();
				let mut key_derivation_params_nonref = (*key_derivation_params).clone();
				let (mut orig_key_derivation_params_nonref_0, mut orig_key_derivation_params_nonref_1) = key_derivation_params_nonref; let mut local_key_derivation_params_nonref = (orig_key_derivation_params_nonref_0, orig_key_derivation_params_nonref_1).into();
				let mut revocation_pubkey_nonref = (*revocation_pubkey).clone();
				SpendableOutputDescriptor::DynamicOutputP2WSH {
					outpoint: crate::chain::transaction::OutPoint { inner: Box::into_raw(Box::new(outpoint_nonref)), is_owned: true },
					per_commitment_point: crate::c_types::PublicKey::from_rust(&per_commitment_point_nonref),
					to_self_delay: to_self_delay_nonref,
					output: crate::c_types::TxOut::from_rust(output_nonref),
					key_derivation_params: local_key_derivation_params_nonref,
					revocation_pubkey: crate::c_types::PublicKey::from_rust(&revocation_pubkey_nonref),
				}
			},
			nativeSpendableOutputDescriptor::StaticOutputCounterpartyPayment {ref outpoint, ref output, ref key_derivation_params, } => {
				let mut outpoint_nonref = (*outpoint).clone();
				let mut output_nonref = (*output).clone();
				let mut key_derivation_params_nonref = (*key_derivation_params).clone();
				let (mut orig_key_derivation_params_nonref_0, mut orig_key_derivation_params_nonref_1) = key_derivation_params_nonref; let mut local_key_derivation_params_nonref = (orig_key_derivation_params_nonref_0, orig_key_derivation_params_nonref_1).into();
				SpendableOutputDescriptor::StaticOutputCounterpartyPayment {
					outpoint: crate::chain::transaction::OutPoint { inner: Box::into_raw(Box::new(outpoint_nonref)), is_owned: true },
					output: crate::c_types::TxOut::from_rust(output_nonref),
					key_derivation_params: local_key_derivation_params_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeSpendableOutputDescriptor) -> Self {
		match native {
			nativeSpendableOutputDescriptor::StaticOutput {mut outpoint, mut output, } => {
				SpendableOutputDescriptor::StaticOutput {
					outpoint: crate::chain::transaction::OutPoint { inner: Box::into_raw(Box::new(outpoint)), is_owned: true },
					output: crate::c_types::TxOut::from_rust(output),
				}
			},
			nativeSpendableOutputDescriptor::DynamicOutputP2WSH {mut outpoint, mut per_commitment_point, mut to_self_delay, mut output, mut key_derivation_params, mut revocation_pubkey, } => {
				let (mut orig_key_derivation_params_0, mut orig_key_derivation_params_1) = key_derivation_params; let mut local_key_derivation_params = (orig_key_derivation_params_0, orig_key_derivation_params_1).into();
				SpendableOutputDescriptor::DynamicOutputP2WSH {
					outpoint: crate::chain::transaction::OutPoint { inner: Box::into_raw(Box::new(outpoint)), is_owned: true },
					per_commitment_point: crate::c_types::PublicKey::from_rust(&per_commitment_point),
					to_self_delay: to_self_delay,
					output: crate::c_types::TxOut::from_rust(output),
					key_derivation_params: local_key_derivation_params,
					revocation_pubkey: crate::c_types::PublicKey::from_rust(&revocation_pubkey),
				}
			},
			nativeSpendableOutputDescriptor::StaticOutputCounterpartyPayment {mut outpoint, mut output, mut key_derivation_params, } => {
				let (mut orig_key_derivation_params_0, mut orig_key_derivation_params_1) = key_derivation_params; let mut local_key_derivation_params = (orig_key_derivation_params_0, orig_key_derivation_params_1).into();
				SpendableOutputDescriptor::StaticOutputCounterpartyPayment {
					outpoint: crate::chain::transaction::OutPoint { inner: Box::into_raw(Box::new(outpoint)), is_owned: true },
					output: crate::c_types::TxOut::from_rust(output),
					key_derivation_params: local_key_derivation_params,
				}
			},
		}
	}
}
#[no_mangle]
pub extern "C" fn SpendableOutputDescriptor_free(this_ptr: SpendableOutputDescriptor) { }
#[no_mangle]
pub extern "C" fn SpendableOutputDescriptor_clone(orig: &SpendableOutputDescriptor) -> SpendableOutputDescriptor {
	orig.clone()
}
/// Set of lightning keys needed to operate a channel as described in BOLT 3.
///
/// Signing services could be implemented on a hardware wallet. In this case,
/// the current ChannelKeys would be a front-end on top of a communication
/// channel connected to your secure device and lightning key material wouldn't
/// reside on a hot server. Nevertheless, a this deployment would still need
/// to trust the ChannelManager to avoid loss of funds as this latest component
/// could ask to sign commitment transaction with HTLCs paying to attacker pubkeys.
///
/// A more secure iteration would be to use hashlock (or payment points) to pair
/// invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager
/// at the price of more state and computation on the hardware wallet side. In the future,
/// we are looking forward to design such interface.
///
/// In any case, ChannelMonitor or fallback watchtowers are always going to be trusted
/// to act, as liveness and breach reply correctness are always going to be hard requirements
/// of LN security model, orthogonal of key management issues.
///
/// If you're implementing a custom signer, you almost certainly want to implement
/// Readable/Writable to serialize out a unique reference to this set of keys so
/// that you can serialize the full ChannelManager object.
///
#[repr(C)]
pub struct ChannelKeys {
	pub this_arg: *mut c_void,
	/// Gets the per-commitment point for a specific commitment number
	///
	/// Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
	#[must_use]
	pub get_per_commitment_point: extern "C" fn (this_arg: *const c_void, idx: u64) -> crate::c_types::PublicKey,
	/// Gets the commitment secret for a specific commitment number as part of the revocation process
	///
	/// An external signer implementation should error here if the commitment was already signed
	/// and should refuse to sign it in the future.
	///
	/// May be called more than once for the same index.
	///
	/// Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
	/// TODO: return a Result so we can signal a validation error
	#[must_use]
	pub release_commitment_secret: extern "C" fn (this_arg: *const c_void, idx: u64) -> crate::c_types::ThirtyTwoBytes,
	/// Gets the holder's channel public keys and basepoints
	pub pubkeys: crate::ln::chan_utils::ChannelPublicKeys,
	/// Fill in the pubkeys field as a reference to it will be given to Rust after this returns
	/// Note that this takes a pointer to this object, not the this_ptr like other methods do
	/// This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
	pub set_pubkeys: Option<extern "C" fn(&ChannelKeys)>,
	/// Gets arbitrary identifiers describing the set of keys which are provided back to you in
	/// some SpendableOutputDescriptor types. These should be sufficient to identify this
	/// ChannelKeys object uniquely and lookup or re-derive its keys.
	#[must_use]
	pub key_derivation_params: extern "C" fn (this_arg: *const c_void) -> crate::c_types::derived::C2Tuple_u64u64Z,
	/// Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
	///
	/// Note that if signing fails or is rejected, the channel will be force-closed.
	#[must_use]
	pub sign_counterparty_commitment: extern "C" fn (this_arg: *const c_void, feerate_per_kw: u32, commitment_tx: crate::c_types::Transaction, keys: &crate::ln::chan_utils::PreCalculatedTxCreationKeys, htlcs: crate::c_types::derived::CVec_HTLCOutputInCommitmentZ) -> crate::c_types::derived::CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ,
	/// Create a signature for a holder's commitment transaction. This will only ever be called with
	/// the same holder_commitment_tx (or a copy thereof), though there are currently no guarantees
	/// that it will not be called multiple times.
	/// An external signer implementation should check that the commitment has not been revoked.
	#[must_use]
	pub sign_holder_commitment: extern "C" fn (this_arg: *const c_void, holder_commitment_tx: &crate::ln::chan_utils::HolderCommitmentTransaction) -> crate::c_types::derived::CResult_SignatureNoneZ,
	/// Create a signature for each HTLC transaction spending a holder's commitment transaction.
	///
	/// Unlike sign_holder_commitment, this may be called multiple times with *different*
	/// holder_commitment_tx values. While this will never be called with a revoked
	/// holder_commitment_tx, it is possible that it is called with the second-latest
	/// holder_commitment_tx (only if we haven't yet revoked it) if some watchtower/secondary
	/// ChannelMonitor decided to broadcast before it had been updated to the latest.
	///
	/// Either an Err should be returned, or a Vec with one entry for each HTLC which exists in
	/// holder_commitment_tx. For those HTLCs which have transaction_output_index set to None
	/// (implying they were considered dust at the time the commitment transaction was negotiated),
	/// a corresponding None should be included in the return value. All other positions in the
	/// return value must contain a signature.
	#[must_use]
	pub sign_holder_commitment_htlc_transactions: extern "C" fn (this_arg: *const c_void, holder_commitment_tx: &crate::ln::chan_utils::HolderCommitmentTransaction) -> crate::c_types::derived::CResult_CVec_SignatureZNoneZ,
	/// Create a signature for the given input in a transaction spending an HTLC or commitment
	/// transaction output when our counterparty broadcasts an old state.
	///
	/// A justice transaction may claim multiples outputs at the same time if timelocks are
	/// similar, but only a signature for the input at index `input` should be signed for here.
	/// It may be called multiples time for same output(s) if a fee-bump is needed with regards
	/// to an upcoming timelock expiration.
	///
	/// Amount is value of the output spent by this input, committed to in the BIP 143 signature.
	///
	/// per_commitment_key is revocation secret which was provided by our counterparty when they
	/// revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
	/// not allow the spending of any funds by itself (you need our holder revocation_secret to do
	/// so).
	///
	/// htlc holds HTLC elements (hash, timelock) if the output being spent is a HTLC output, thus
	/// changing the format of the witness script (which is committed to in the BIP 143
	/// signatures).
	#[must_use]
	pub sign_justice_transaction: extern "C" fn (this_arg: *const c_void, justice_tx: crate::c_types::Transaction, input: usize, amount: u64, per_commitment_key: *const [u8; 32], htlc: &crate::ln::chan_utils::HTLCOutputInCommitment) -> crate::c_types::derived::CResult_SignatureNoneZ,
	/// Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
	/// transaction, either offered or received.
	///
	/// Such a transaction may claim multiples offered outputs at same time if we know the
	/// preimage for each when we create it, but only the input at index `input` should be
	/// signed for here. It may be called multiple times for same output(s) if a fee-bump is
	/// needed with regards to an upcoming timelock expiration.
	///
	/// Witness_script is either a offered or received script as defined in BOLT3 for HTLC
	/// outputs.
	///
	/// Amount is value of the output spent by this input, committed to in the BIP 143 signature.
	///
	/// Per_commitment_point is the dynamic point corresponding to the channel state
	/// detected onchain. It has been generated by our counterparty and is used to derive
	/// channel state keys, which are then included in the witness script and committed to in the
	/// BIP 143 signature.
	#[must_use]
	pub sign_counterparty_htlc_transaction: extern "C" fn (this_arg: *const c_void, htlc_tx: crate::c_types::Transaction, input: usize, amount: u64, per_commitment_point: crate::c_types::PublicKey, htlc: &crate::ln::chan_utils::HTLCOutputInCommitment) -> crate::c_types::derived::CResult_SignatureNoneZ,
	/// Create a signature for a (proposed) closing transaction.
	///
	/// Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
	/// chosen to forgo their output as dust.
	#[must_use]
	pub sign_closing_transaction: extern "C" fn (this_arg: *const c_void, closing_tx: crate::c_types::Transaction) -> crate::c_types::derived::CResult_SignatureNoneZ,
	/// Signs a channel announcement message with our funding key, proving it comes from one
	/// of the channel participants.
	///
	/// Note that if this fails or is rejected, the channel will not be publicly announced and
	/// our counterparty may (though likely will not) close the channel on us for violating the
	/// protocol.
	#[must_use]
	pub sign_channel_announcement: extern "C" fn (this_arg: *const c_void, msg: &crate::ln::msgs::UnsignedChannelAnnouncement) -> crate::c_types::derived::CResult_SignatureNoneZ,
	/// Set the counterparty channel basepoints and counterparty_selected/holder_selected_contest_delay.
	/// This is done immediately on incoming channels and as soon as the channel is accepted on outgoing channels.
	///
	/// We bind holder_selected_contest_delay late here for API convenience.
	///
	/// Will be called before any signatures are applied.
	pub on_accept: extern "C" fn (this_arg: *mut c_void, channel_points: &crate::ln::chan_utils::ChannelPublicKeys, counterparty_selected_contest_delay: u16, holder_selected_contest_delay: u16),
	pub clone: Option<extern "C" fn (this_arg: *const c_void) -> *mut c_void>,
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for ChannelKeys {}
#[no_mangle]
pub extern "C" fn ChannelKeys_clone(orig: &ChannelKeys) -> ChannelKeys {
	ChannelKeys {
		this_arg: if let Some(f) = orig.clone { (f)(orig.this_arg) } else { orig.this_arg },
		get_per_commitment_point: orig.get_per_commitment_point.clone(),
		release_commitment_secret: orig.release_commitment_secret.clone(),
		pubkeys: orig.pubkeys.clone(),
		set_pubkeys: orig.set_pubkeys.clone(),
		key_derivation_params: orig.key_derivation_params.clone(),
		sign_counterparty_commitment: orig.sign_counterparty_commitment.clone(),
		sign_holder_commitment: orig.sign_holder_commitment.clone(),
		sign_holder_commitment_htlc_transactions: orig.sign_holder_commitment_htlc_transactions.clone(),
		sign_justice_transaction: orig.sign_justice_transaction.clone(),
		sign_counterparty_htlc_transaction: orig.sign_counterparty_htlc_transaction.clone(),
		sign_closing_transaction: orig.sign_closing_transaction.clone(),
		sign_channel_announcement: orig.sign_channel_announcement.clone(),
		on_accept: orig.on_accept.clone(),
		clone: orig.clone.clone(),
		free: orig.free.clone(),
	}
}
impl Clone for ChannelKeys {
	fn clone(&self) -> Self {
		ChannelKeys_clone(self)
	}
}

use lightning::chain::keysinterface::ChannelKeys as rustChannelKeys;
impl rustChannelKeys for ChannelKeys {
	fn get_per_commitment_point<T:bitcoin::secp256k1::Signing + bitcoin::secp256k1::Verification>(&self, idx: u64, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> bitcoin::secp256k1::key::PublicKey {
		let mut ret = (self.get_per_commitment_point)(self.this_arg, idx);
		ret.into_rust()
	}
	fn release_commitment_secret(&self, idx: u64) -> [u8; 32] {
		let mut ret = (self.release_commitment_secret)(self.this_arg, idx);
		ret.data
	}
	fn pubkeys(&self) -> &lightning::ln::chan_utils::ChannelPublicKeys {
		if let Some(f) = self.set_pubkeys {
			(f)(self);
		}
		unsafe { &*self.pubkeys.inner }
	}
	fn key_derivation_params(&self) -> (u64, u64) {
		let mut ret = (self.key_derivation_params)(self.this_arg);
		let (mut orig_ret_0, mut orig_ret_1) = ret.to_rust(); let mut local_ret = (orig_ret_0, orig_ret_1);
		local_ret
	}
	fn sign_counterparty_commitment<T:bitcoin::secp256k1::Signing + bitcoin::secp256k1::Verification>(&self, feerate_per_kw: u32, commitment_tx: &bitcoin::blockdata::transaction::Transaction, keys: &lightning::ln::chan_utils::PreCalculatedTxCreationKeys, htlcs: &[&lightning::ln::chan_utils::HTLCOutputInCommitment], _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<(bitcoin::secp256k1::Signature, Vec<bitcoin::secp256k1::Signature>), ()> {
		let mut local_commitment_tx = ::bitcoin::consensus::encode::serialize(commitment_tx);
		let mut local_htlcs = Vec::new(); for item in htlcs.iter() { local_htlcs.push( { crate::ln::chan_utils::HTLCOutputInCommitment { inner: unsafe { ( (&(**item) as *const _) as *mut _) }, is_owned: false } }); };
		let mut ret = (self.sign_counterparty_commitment)(self.this_arg, feerate_per_kw, crate::c_types::Transaction::from_vec(local_commitment_tx), &crate::ln::chan_utils::PreCalculatedTxCreationKeys { inner: unsafe { (keys as *const _) as *mut _ }, is_owned: false }, local_htlcs.into());
		let mut local_ret = match ret.result_ok { true => Ok( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).to_rust(); let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.into_rust().drain(..) { local_orig_ret_0_1.push( { item.into_rust() }); }; let mut local_ret_0 = (orig_ret_0_0.into_rust(), local_orig_ret_0_1); local_ret_0 }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn sign_holder_commitment<T:bitcoin::secp256k1::Signing + bitcoin::secp256k1::Verification>(&self, holder_commitment_tx: &lightning::ln::chan_utils::HolderCommitmentTransaction, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<bitcoin::secp256k1::Signature, ()> {
		let mut ret = (self.sign_holder_commitment)(self.this_arg, &crate::ln::chan_utils::HolderCommitmentTransaction { inner: unsafe { (holder_commitment_tx as *const _) as *mut _ }, is_owned: false });
		let mut local_ret = match ret.result_ok { true => Ok( { (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).into_rust() }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn sign_holder_commitment_htlc_transactions<T:bitcoin::secp256k1::Signing + bitcoin::secp256k1::Verification>(&self, holder_commitment_tx: &lightning::ln::chan_utils::HolderCommitmentTransaction, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<Vec<Option<bitcoin::secp256k1::Signature>>, ()> {
		let mut ret = (self.sign_holder_commitment_htlc_transactions)(self.this_arg, &crate::ln::chan_utils::HolderCommitmentTransaction { inner: unsafe { (holder_commitment_tx as *const _) as *mut _ }, is_owned: false });
		let mut local_ret = match ret.result_ok { true => Ok( { let mut local_ret_0 = Vec::new(); for mut item in (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).into_rust().drain(..) { local_ret_0.push( { let mut local_ret_0_0 = if item.is_null() { None } else { Some( { item.into_rust() }) }; local_ret_0_0 }); }; local_ret_0 }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn sign_justice_transaction<T:bitcoin::secp256k1::Signing + bitcoin::secp256k1::Verification>(&self, justice_tx: &bitcoin::blockdata::transaction::Transaction, input: usize, amount: u64, per_commitment_key: &bitcoin::secp256k1::key::SecretKey, htlc: &Option<lightning::ln::chan_utils::HTLCOutputInCommitment>, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<bitcoin::secp256k1::Signature, ()> {
		let mut local_justice_tx = ::bitcoin::consensus::encode::serialize(justice_tx);
		let mut local_htlc = &crate::ln::chan_utils::HTLCOutputInCommitment { inner: unsafe { (if htlc.is_none() { std::ptr::null() } else {  { (htlc.as_ref().unwrap()) } } as *const _) as *mut _ }, is_owned: false };
		let mut ret = (self.sign_justice_transaction)(self.this_arg, crate::c_types::Transaction::from_vec(local_justice_tx), input, amount, per_commitment_key.as_ref(), local_htlc);
		let mut local_ret = match ret.result_ok { true => Ok( { (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).into_rust() }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn sign_counterparty_htlc_transaction<T:bitcoin::secp256k1::Signing + bitcoin::secp256k1::Verification>(&self, htlc_tx: &bitcoin::blockdata::transaction::Transaction, input: usize, amount: u64, per_commitment_point: &bitcoin::secp256k1::key::PublicKey, htlc: &lightning::ln::chan_utils::HTLCOutputInCommitment, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<bitcoin::secp256k1::Signature, ()> {
		let mut local_htlc_tx = ::bitcoin::consensus::encode::serialize(htlc_tx);
		let mut ret = (self.sign_counterparty_htlc_transaction)(self.this_arg, crate::c_types::Transaction::from_vec(local_htlc_tx), input, amount, crate::c_types::PublicKey::from_rust(&per_commitment_point), &crate::ln::chan_utils::HTLCOutputInCommitment { inner: unsafe { (htlc as *const _) as *mut _ }, is_owned: false });
		let mut local_ret = match ret.result_ok { true => Ok( { (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).into_rust() }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn sign_closing_transaction<T:bitcoin::secp256k1::Signing>(&self, closing_tx: &bitcoin::blockdata::transaction::Transaction, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<bitcoin::secp256k1::Signature, ()> {
		let mut local_closing_tx = ::bitcoin::consensus::encode::serialize(closing_tx);
		let mut ret = (self.sign_closing_transaction)(self.this_arg, crate::c_types::Transaction::from_vec(local_closing_tx));
		let mut local_ret = match ret.result_ok { true => Ok( { (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).into_rust() }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn sign_channel_announcement<T:bitcoin::secp256k1::Signing>(&self, msg: &lightning::ln::msgs::UnsignedChannelAnnouncement, _secp_ctx: &bitcoin::secp256k1::Secp256k1<T>) -> Result<bitcoin::secp256k1::Signature, ()> {
		let mut ret = (self.sign_channel_announcement)(self.this_arg, &crate::ln::msgs::UnsignedChannelAnnouncement { inner: unsafe { (msg as *const _) as *mut _ }, is_owned: false });
		let mut local_ret = match ret.result_ok { true => Ok( { (*unsafe { Box::from_raw(ret.contents.result.take_ptr()) }).into_rust() }), false => Err( { () /*(*unsafe { Box::from_raw(ret.contents.err.take_ptr()) })*/ })};
		local_ret
	}
	fn on_accept(&mut self, channel_points: &lightning::ln::chan_utils::ChannelPublicKeys, counterparty_selected_contest_delay: u16, holder_selected_contest_delay: u16) {
		(self.on_accept)(self.this_arg, &crate::ln::chan_utils::ChannelPublicKeys { inner: unsafe { (channel_points as *const _) as *mut _ }, is_owned: false }, counterparty_selected_contest_delay, holder_selected_contest_delay)
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl std::ops::Deref for ChannelKeys {
	type Target = Self;
	fn deref(&self) -> &Self {
		self
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn ChannelKeys_free(this_ptr: ChannelKeys) { }
impl Drop for ChannelKeys {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}
/// A trait to describe an object which can get user secrets and key material.
#[repr(C)]
pub struct KeysInterface {
	pub this_arg: *mut c_void,
	/// Get node secret key (aka node_id or network_key)
	#[must_use]
	pub get_node_secret: extern "C" fn (this_arg: *const c_void) -> crate::c_types::SecretKey,
	/// Get destination redeemScript to encumber static protocol exit points.
	#[must_use]
	pub get_destination_script: extern "C" fn (this_arg: *const c_void) -> crate::c_types::derived::CVec_u8Z,
	/// Get shutdown_pubkey to use as PublicKey at channel closure
	#[must_use]
	pub get_shutdown_pubkey: extern "C" fn (this_arg: *const c_void) -> crate::c_types::PublicKey,
	/// Get a new set of ChannelKeys for per-channel secrets. These MUST be unique even if you
	/// restarted with some stale data!
	#[must_use]
	pub get_channel_keys: extern "C" fn (this_arg: *const c_void, inbound: bool, channel_value_satoshis: u64) -> crate::chain::keysinterface::ChannelKeys,
	/// Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
	/// onion packets and for temporary channel IDs. There is no requirement that these be
	/// persisted anywhere, though they must be unique across restarts.
	#[must_use]
	pub get_secure_random_bytes: extern "C" fn (this_arg: *const c_void) -> crate::c_types::ThirtyTwoBytes,
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for KeysInterface {}
unsafe impl Sync for KeysInterface {}

use lightning::chain::keysinterface::KeysInterface as rustKeysInterface;
impl rustKeysInterface for KeysInterface {
	type ChanKeySigner = crate::chain::keysinterface::ChannelKeys;
	fn get_node_secret(&self) -> bitcoin::secp256k1::key::SecretKey {
		let mut ret = (self.get_node_secret)(self.this_arg);
		ret.into_rust()
	}
	fn get_destination_script(&self) -> bitcoin::blockdata::script::Script {
		let mut ret = (self.get_destination_script)(self.this_arg);
		::bitcoin::blockdata::script::Script::from(ret.into_rust())
	}
	fn get_shutdown_pubkey(&self) -> bitcoin::secp256k1::key::PublicKey {
		let mut ret = (self.get_shutdown_pubkey)(self.this_arg);
		ret.into_rust()
	}
	fn get_channel_keys(&self, inbound: bool, channel_value_satoshis: u64) -> Self::ChanKeySigner {
		let mut ret = (self.get_channel_keys)(self.this_arg, inbound, channel_value_satoshis);
		ret
	}
	fn get_secure_random_bytes(&self) -> [u8; 32] {
		let mut ret = (self.get_secure_random_bytes)(self.this_arg);
		ret.data
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl std::ops::Deref for KeysInterface {
	type Target = Self;
	fn deref(&self) -> &Self {
		self
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn KeysInterface_free(this_ptr: KeysInterface) { }
impl Drop for KeysInterface {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}

use lightning::chain::keysinterface::InMemoryChannelKeys as nativeInMemoryChannelKeysImport;
type nativeInMemoryChannelKeys = nativeInMemoryChannelKeysImport;

/// A simple implementation of ChannelKeys that just keeps the private keys in memory.
#[must_use]
#[repr(C)]
pub struct InMemoryChannelKeys {
	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeInMemoryChannelKeys,
	pub is_owned: bool,
}

impl Drop for InMemoryChannelKeys {
	fn drop(&mut self) {
		if self.is_owned && !self.inner.is_null() {
			let _ = unsafe { Box::from_raw(self.inner) };
		}
	}
}
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_free(this_ptr: InMemoryChannelKeys) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
extern "C" fn InMemoryChannelKeys_free_void(this_ptr: *mut c_void) {
	unsafe { let _ = Box::from_raw(this_ptr as *mut nativeInMemoryChannelKeys); }
}
#[allow(unused)]
/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
impl InMemoryChannelKeys {
	pub(crate) fn take_ptr(mut self) -> *mut nativeInMemoryChannelKeys {
		assert!(self.is_owned);
		let ret = self.inner;
		self.inner = std::ptr::null_mut();
		ret
	}
}
impl Clone for InMemoryChannelKeys {
	fn clone(&self) -> Self {
		Self {
			inner: Box::into_raw(Box::new(unsafe { &*self.inner }.clone())),
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn InMemoryChannelKeys_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *mut nativeInMemoryChannelKeys)).clone() })) as *mut c_void
}
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_clone(orig: &InMemoryChannelKeys) -> InMemoryChannelKeys {
	InMemoryChannelKeys { inner: Box::into_raw(Box::new(unsafe { &*orig.inner }.clone())), is_owned: true }
}
/// Private key of anchor tx
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_get_funding_key(this_ptr: &InMemoryChannelKeys) -> *const [u8; 32] {
	let mut inner_val = &mut unsafe { &mut *this_ptr.inner }.funding_key;
	(*inner_val).as_ref()
}
/// Private key of anchor tx
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_set_funding_key(this_ptr: &mut InMemoryChannelKeys, mut val: crate::c_types::SecretKey) {
	unsafe { &mut *this_ptr.inner }.funding_key = val.into_rust();
}
/// Holder secret key for blinded revocation pubkey
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_get_revocation_base_key(this_ptr: &InMemoryChannelKeys) -> *const [u8; 32] {
	let mut inner_val = &mut unsafe { &mut *this_ptr.inner }.revocation_base_key;
	(*inner_val).as_ref()
}
/// Holder secret key for blinded revocation pubkey
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_set_revocation_base_key(this_ptr: &mut InMemoryChannelKeys, mut val: crate::c_types::SecretKey) {
	unsafe { &mut *this_ptr.inner }.revocation_base_key = val.into_rust();
}
/// Holder secret key used for our balance in counterparty-broadcasted commitment transactions
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_get_payment_key(this_ptr: &InMemoryChannelKeys) -> *const [u8; 32] {
	let mut inner_val = &mut unsafe { &mut *this_ptr.inner }.payment_key;
	(*inner_val).as_ref()
}
/// Holder secret key used for our balance in counterparty-broadcasted commitment transactions
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_set_payment_key(this_ptr: &mut InMemoryChannelKeys, mut val: crate::c_types::SecretKey) {
	unsafe { &mut *this_ptr.inner }.payment_key = val.into_rust();
}
/// Holder secret key used in HTLC tx
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_get_delayed_payment_base_key(this_ptr: &InMemoryChannelKeys) -> *const [u8; 32] {
	let mut inner_val = &mut unsafe { &mut *this_ptr.inner }.delayed_payment_base_key;
	(*inner_val).as_ref()
}
/// Holder secret key used in HTLC tx
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_set_delayed_payment_base_key(this_ptr: &mut InMemoryChannelKeys, mut val: crate::c_types::SecretKey) {
	unsafe { &mut *this_ptr.inner }.delayed_payment_base_key = val.into_rust();
}
/// Holder htlc secret key used in commitment tx htlc outputs
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_get_htlc_base_key(this_ptr: &InMemoryChannelKeys) -> *const [u8; 32] {
	let mut inner_val = &mut unsafe { &mut *this_ptr.inner }.htlc_base_key;
	(*inner_val).as_ref()
}
/// Holder htlc secret key used in commitment tx htlc outputs
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_set_htlc_base_key(this_ptr: &mut InMemoryChannelKeys, mut val: crate::c_types::SecretKey) {
	unsafe { &mut *this_ptr.inner }.htlc_base_key = val.into_rust();
}
/// Commitment seed
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_get_commitment_seed(this_ptr: &InMemoryChannelKeys) -> *const [u8; 32] {
	let mut inner_val = &mut unsafe { &mut *this_ptr.inner }.commitment_seed;
	&(*inner_val)
}
/// Commitment seed
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_set_commitment_seed(this_ptr: &mut InMemoryChannelKeys, mut val: crate::c_types::ThirtyTwoBytes) {
	unsafe { &mut *this_ptr.inner }.commitment_seed = val.data;
}
/// Create a new InMemoryChannelKeys
#[must_use]
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_new(mut funding_key: crate::c_types::SecretKey, mut revocation_base_key: crate::c_types::SecretKey, mut payment_key: crate::c_types::SecretKey, mut delayed_payment_base_key: crate::c_types::SecretKey, mut htlc_base_key: crate::c_types::SecretKey, mut commitment_seed: crate::c_types::ThirtyTwoBytes, mut channel_value_satoshis: u64, mut key_derivation_params: crate::c_types::derived::C2Tuple_u64u64Z) -> crate::chain::keysinterface::InMemoryChannelKeys {
	let (mut orig_key_derivation_params_0, mut orig_key_derivation_params_1) = key_derivation_params.to_rust(); let mut local_key_derivation_params = (orig_key_derivation_params_0, orig_key_derivation_params_1);
	let mut ret = lightning::chain::keysinterface::InMemoryChannelKeys::new(&bitcoin::secp256k1::Secp256k1::new(), funding_key.into_rust(), revocation_base_key.into_rust(), payment_key.into_rust(), delayed_payment_base_key.into_rust(), htlc_base_key.into_rust(), commitment_seed.data, channel_value_satoshis, local_key_derivation_params);
	crate::chain::keysinterface::InMemoryChannelKeys { inner: Box::into_raw(Box::new(ret)), is_owned: true }
}

/// Counterparty pubkeys.
/// Will panic if on_accept wasn't called.
#[must_use]
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_counterparty_pubkeys(this_arg: &InMemoryChannelKeys) -> crate::ln::chan_utils::ChannelPublicKeys {
	let mut ret = unsafe { &*this_arg.inner }.counterparty_pubkeys();
	crate::ln::chan_utils::ChannelPublicKeys { inner: unsafe { ( (&(*ret) as *const _) as *mut _) }, is_owned: false }
}

/// The contest_delay value specified by our counterparty and applied on holder-broadcastable
/// transactions, ie the amount of time that we have to wait to recover our funds if we
/// broadcast a transaction. You'll likely want to pass this to the
/// ln::chan_utils::build*_transaction functions when signing holder's transactions.
/// Will panic if on_accept wasn't called.
#[must_use]
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_counterparty_selected_contest_delay(this_arg: &InMemoryChannelKeys) -> u16 {
	let mut ret = unsafe { &*this_arg.inner }.counterparty_selected_contest_delay();
	ret
}

/// The contest_delay value specified by us and applied on transactions broadcastable
/// by our counterparty, ie the amount of time that they have to wait to recover their funds
/// if they broadcast a transaction.
/// Will panic if on_accept wasn't called.
#[must_use]
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_holder_selected_contest_delay(this_arg: &InMemoryChannelKeys) -> u16 {
	let mut ret = unsafe { &*this_arg.inner }.holder_selected_contest_delay();
	ret
}

#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_as_ChannelKeys(this_arg: *const InMemoryChannelKeys) -> crate::chain::keysinterface::ChannelKeys {
	crate::chain::keysinterface::ChannelKeys {
		this_arg: unsafe { (*this_arg).inner as *mut c_void },
		free: None,
		get_per_commitment_point: InMemoryChannelKeys_ChannelKeys_get_per_commitment_point,
		release_commitment_secret: InMemoryChannelKeys_ChannelKeys_release_commitment_secret,

		pubkeys: crate::ln::chan_utils::ChannelPublicKeys { inner: std::ptr::null_mut(), is_owned: true },
		set_pubkeys: Some(InMemoryChannelKeys_ChannelKeys_set_pubkeys),
		key_derivation_params: InMemoryChannelKeys_ChannelKeys_key_derivation_params,
		sign_counterparty_commitment: InMemoryChannelKeys_ChannelKeys_sign_counterparty_commitment,
		sign_holder_commitment: InMemoryChannelKeys_ChannelKeys_sign_holder_commitment,
		sign_holder_commitment_htlc_transactions: InMemoryChannelKeys_ChannelKeys_sign_holder_commitment_htlc_transactions,
		sign_justice_transaction: InMemoryChannelKeys_ChannelKeys_sign_justice_transaction,
		sign_counterparty_htlc_transaction: InMemoryChannelKeys_ChannelKeys_sign_counterparty_htlc_transaction,
		sign_closing_transaction: InMemoryChannelKeys_ChannelKeys_sign_closing_transaction,
		sign_channel_announcement: InMemoryChannelKeys_ChannelKeys_sign_channel_announcement,
		on_accept: InMemoryChannelKeys_ChannelKeys_on_accept,
		clone: Some(InMemoryChannelKeys_clone_void),
	}
}
use lightning::chain::keysinterface::ChannelKeys as ChannelKeysTraitImport;
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_get_per_commitment_point(this_arg: *const c_void, mut idx: u64) -> crate::c_types::PublicKey {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.get_per_commitment_point(idx, &bitcoin::secp256k1::Secp256k1::new());
	crate::c_types::PublicKey::from_rust(&ret)
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_release_commitment_secret(this_arg: *const c_void, mut idx: u64) -> crate::c_types::ThirtyTwoBytes {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.release_commitment_secret(idx);
	crate::c_types::ThirtyTwoBytes { data: ret }
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_pubkeys(this_arg: *const c_void) -> crate::ln::chan_utils::ChannelPublicKeys {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.pubkeys();
	crate::ln::chan_utils::ChannelPublicKeys { inner: unsafe { ( (&(*ret) as *const _) as *mut _) }, is_owned: false }
}
extern "C" fn InMemoryChannelKeys_ChannelKeys_set_pubkeys(trait_self_arg: &ChannelKeys) {
	// This is a bit race-y in the general case, but for our specific use-cases today, we're safe
	// Specifically, we must ensure that the first time we're called it can never be in parallel
	if trait_self_arg.pubkeys.inner.is_null() {
		unsafe { &mut *(trait_self_arg as *const ChannelKeys  as *mut ChannelKeys) }.pubkeys = InMemoryChannelKeys_ChannelKeys_pubkeys(trait_self_arg.this_arg);
	}
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_key_derivation_params(this_arg: *const c_void) -> crate::c_types::derived::C2Tuple_u64u64Z {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.key_derivation_params();
	let (mut orig_ret_0, mut orig_ret_1) = ret; let mut local_ret = (orig_ret_0, orig_ret_1).into();
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_counterparty_commitment(this_arg: *const c_void, mut feerate_per_kw: u32, mut commitment_tx: crate::c_types::Transaction, pre_keys: &crate::ln::chan_utils::PreCalculatedTxCreationKeys, mut htlcs: crate::c_types::derived::CVec_HTLCOutputInCommitmentZ) -> crate::c_types::derived::CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ {
	let mut local_htlcs = Vec::new(); for mut item in htlcs.as_slice().iter() { local_htlcs.push( { unsafe { &*item.inner } }); };
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_counterparty_commitment(feerate_per_kw, &commitment_tx.into_bitcoin(), unsafe { &*pre_keys.inner }, &local_htlcs[..], &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let (mut orig_ret_0_0, mut orig_ret_0_1) = o; let mut local_orig_ret_0_1 = Vec::new(); for item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { crate::c_types::Signature::from_rust(&item) }); }; let mut local_ret_0 = (crate::c_types::Signature::from_rust(&orig_ret_0_0), local_orig_ret_0_1.into()).into(); local_ret_0 }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_holder_commitment(this_arg: *const c_void, holder_commitment_tx: &crate::ln::chan_utils::HolderCommitmentTransaction) -> crate::c_types::derived::CResult_SignatureNoneZ {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_holder_commitment(unsafe { &*holder_commitment_tx.inner }, &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::Signature::from_rust(&o) }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_holder_commitment_htlc_transactions(this_arg: *const c_void, holder_commitment_tx: &crate::ln::chan_utils::HolderCommitmentTransaction) -> crate::c_types::derived::CResult_CVec_SignatureZNoneZ {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_holder_commitment_htlc_transactions(unsafe { &*holder_commitment_tx.inner }, &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = Vec::new(); for item in o.drain(..) { local_ret_0.push( { let mut local_ret_0_0 = if item.is_none() { crate::c_types::Signature::null() } else {  { crate::c_types::Signature::from_rust(&(item.unwrap())) } }; local_ret_0_0 }); }; local_ret_0.into() }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_justice_transaction(this_arg: *const c_void, mut justice_tx: crate::c_types::Transaction, mut input: usize, mut amount: u64, per_commitment_key: *const [u8; 32], htlc: &crate::ln::chan_utils::HTLCOutputInCommitment) -> crate::c_types::derived::CResult_SignatureNoneZ {
	let mut local_htlc = if htlc.inner.is_null() { None } else { Some((* { unsafe { &*htlc.inner } }).clone()) };
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_justice_transaction(&justice_tx.into_bitcoin(), input, amount, &::bitcoin::secp256k1::key::SecretKey::from_slice(&unsafe { *per_commitment_key}[..]).unwrap(), &local_htlc, &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::Signature::from_rust(&o) }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_counterparty_htlc_transaction(this_arg: *const c_void, mut htlc_tx: crate::c_types::Transaction, mut input: usize, mut amount: u64, mut per_commitment_point: crate::c_types::PublicKey, htlc: &crate::ln::chan_utils::HTLCOutputInCommitment) -> crate::c_types::derived::CResult_SignatureNoneZ {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_counterparty_htlc_transaction(&htlc_tx.into_bitcoin(), input, amount, &per_commitment_point.into_rust(), unsafe { &*htlc.inner }, &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::Signature::from_rust(&o) }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_closing_transaction(this_arg: *const c_void, mut closing_tx: crate::c_types::Transaction) -> crate::c_types::derived::CResult_SignatureNoneZ {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_closing_transaction(&closing_tx.into_bitcoin(), &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::Signature::from_rust(&o) }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
#[must_use]
extern "C" fn InMemoryChannelKeys_ChannelKeys_sign_channel_announcement(this_arg: *const c_void, msg: &crate::ln::msgs::UnsignedChannelAnnouncement) -> crate::c_types::derived::CResult_SignatureNoneZ {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.sign_channel_announcement(unsafe { &*msg.inner }, &bitcoin::secp256k1::Secp256k1::new());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::Signature::from_rust(&o) }), Err(mut e) => crate::c_types::CResultTempl::err( { 0u8 /*e*/ }) };
	local_ret
}
extern "C" fn InMemoryChannelKeys_ChannelKeys_on_accept(this_arg: *mut c_void, channel_pubkeys: &crate::ln::chan_utils::ChannelPublicKeys, mut counterparty_selected_contest_delay: u16, mut holder_selected_contest_delay: u16) {
	unsafe { &mut *(this_arg as *mut nativeInMemoryChannelKeys) }.on_accept(unsafe { &*channel_pubkeys.inner }, counterparty_selected_contest_delay, holder_selected_contest_delay)
}

#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_write(obj: *const InMemoryChannelKeys) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &(*(*obj).inner) })
}
#[no_mangle]
pub extern "C" fn InMemoryChannelKeys_read(ser: crate::c_types::u8slice) -> InMemoryChannelKeys {
	if let Ok(res) = crate::c_types::deserialize_obj(ser) {
		InMemoryChannelKeys { inner: Box::into_raw(Box::new(res)), is_owned: true }
	} else {
		InMemoryChannelKeys { inner: std::ptr::null_mut(), is_owned: true }
	}
}

use lightning::chain::keysinterface::KeysManager as nativeKeysManagerImport;
type nativeKeysManager = nativeKeysManagerImport;

/// Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
/// and derives keys from that.
///
/// Your node_id is seed/0'
/// ChannelMonitor closes may use seed/1'
/// Cooperative closes may use seed/2'
/// The two close keys may be needed to claim on-chain funds!
#[must_use]
#[repr(C)]
pub struct KeysManager {
	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeKeysManager,
	pub is_owned: bool,
}

impl Drop for KeysManager {
	fn drop(&mut self) {
		if self.is_owned && !self.inner.is_null() {
			let _ = unsafe { Box::from_raw(self.inner) };
		}
	}
}
#[no_mangle]
pub extern "C" fn KeysManager_free(this_ptr: KeysManager) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
extern "C" fn KeysManager_free_void(this_ptr: *mut c_void) {
	unsafe { let _ = Box::from_raw(this_ptr as *mut nativeKeysManager); }
}
#[allow(unused)]
/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
impl KeysManager {
	pub(crate) fn take_ptr(mut self) -> *mut nativeKeysManager {
		assert!(self.is_owned);
		let ret = self.inner;
		self.inner = std::ptr::null_mut();
		ret
	}
}
/// Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
/// CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
/// starting_time isn't strictly required to actually be a time, but it must absolutely,
/// without a doubt, be unique to this instance. ie if you start multiple times with the same
/// seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
/// simply use the current time (with very high precision).
///
/// The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
/// obviously, starting_time should be unique every time you reload the library - it is only
/// used to generate new ephemeral key data (which will be stored by the individual channel if
/// necessary).
///
/// Note that the seed is required to recover certain on-chain funds independent of
/// ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
/// channel, and some on-chain during-closing funds.
///
/// Note that until the 0.1 release there is no guarantee of backward compatibility between
/// versions. Once the library is more fully supported, the docs will be updated to include a
/// detailed description of the guarantee.
#[must_use]
#[no_mangle]
pub extern "C" fn KeysManager_new(seed: *const [u8; 32], mut network: crate::bitcoin::network::Network, mut starting_time_secs: u64, mut starting_time_nanos: u32) -> KeysManager {
	let mut ret = lightning::chain::keysinterface::KeysManager::new(unsafe { &*seed}, network.into_bitcoin(), starting_time_secs, starting_time_nanos);
	KeysManager { inner: Box::into_raw(Box::new(ret)), is_owned: true }
}

/// Derive an old set of ChannelKeys for per-channel secrets based on a key derivation
/// parameters.
/// Key derivation parameters are accessible through a per-channel secrets
/// ChannelKeys::key_derivation_params and is provided inside DynamicOuputP2WSH in case of
/// onchain output detection for which a corresponding delayed_payment_key must be derived.
#[must_use]
#[no_mangle]
pub extern "C" fn KeysManager_derive_channel_keys(this_arg: &KeysManager, mut channel_value_satoshis: u64, mut params_1: u64, mut params_2: u64) -> crate::chain::keysinterface::InMemoryChannelKeys {
	let mut ret = unsafe { &*this_arg.inner }.derive_channel_keys(channel_value_satoshis, params_1, params_2);
	crate::chain::keysinterface::InMemoryChannelKeys { inner: Box::into_raw(Box::new(ret)), is_owned: true }
}

#[no_mangle]
pub extern "C" fn KeysManager_as_KeysInterface(this_arg: *const KeysManager) -> crate::chain::keysinterface::KeysInterface {
	crate::chain::keysinterface::KeysInterface {
		this_arg: unsafe { (*this_arg).inner as *mut c_void },
		free: None,
		get_node_secret: KeysManager_KeysInterface_get_node_secret,
		get_destination_script: KeysManager_KeysInterface_get_destination_script,
		get_shutdown_pubkey: KeysManager_KeysInterface_get_shutdown_pubkey,
		get_channel_keys: KeysManager_KeysInterface_get_channel_keys,
		get_secure_random_bytes: KeysManager_KeysInterface_get_secure_random_bytes,
	}
}
use lightning::chain::keysinterface::KeysInterface as KeysInterfaceTraitImport;
#[must_use]
extern "C" fn KeysManager_KeysInterface_get_node_secret(this_arg: *const c_void) -> crate::c_types::SecretKey {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeKeysManager) }.get_node_secret();
	crate::c_types::SecretKey::from_rust(ret)
}
#[must_use]
extern "C" fn KeysManager_KeysInterface_get_destination_script(this_arg: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeKeysManager) }.get_destination_script();
	ret.into_bytes().into()
}
#[must_use]
extern "C" fn KeysManager_KeysInterface_get_shutdown_pubkey(this_arg: *const c_void) -> crate::c_types::PublicKey {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeKeysManager) }.get_shutdown_pubkey();
	crate::c_types::PublicKey::from_rust(&ret)
}
#[must_use]
extern "C" fn KeysManager_KeysInterface_get_channel_keys(this_arg: *const c_void, mut _inbound: bool, mut channel_value_satoshis: u64) -> crate::chain::keysinterface::ChannelKeys {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeKeysManager) }.get_channel_keys(_inbound, channel_value_satoshis);
	let mut rust_obj = InMemoryChannelKeys { inner: Box::into_raw(Box::new(ret)), is_owned: true };
	let mut ret = InMemoryChannelKeys_as_ChannelKeys(&rust_obj);
	// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
	rust_obj.inner = std::ptr::null_mut();
	ret.free = Some(InMemoryChannelKeys_free_void);
	ret

}
#[must_use]
extern "C" fn KeysManager_KeysInterface_get_secure_random_bytes(this_arg: *const c_void) -> crate::c_types::ThirtyTwoBytes {
	let mut ret = unsafe { &mut *(this_arg as *mut nativeKeysManager) }.get_secure_random_bytes();
	crate::c_types::ThirtyTwoBytes { data: ret }
}

